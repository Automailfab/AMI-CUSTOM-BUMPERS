/**
 * Cascading Filters JavaScript
 * 
 * Handles the cascading dropdown behavior for Make → Model → Placement filters.
 * Updates the product grid dynamically based on selected filters.
 * 
 * This script:
 * 1. Manages the cascading dropdown dependencies
 * 2. Updates filter options based on previous selections
 * 3. Handles URL parameter updates for Shopify compatibility
 * 4. Triggers product grid updates
 * 
 * Data Structure Expected:
 * Products should have tags in the format:
 * - Make: "make_[make-name]"
 * - Model: "model_[make-name]_[model-name]" 
 * - Placement: "placement_[make-name]_[model-name]_[placement-name]"
 */

class CascadingFilters {
  constructor() {
    this.form = document.getElementById('CascadingFiltersForm');
    this.makeSelect = document.getElementById('make-select');
    this.modelSelect = document.getElementById('model-select');
    this.placementSelect = document.getElementById('placement-select');
    this.clearButton = document.getElementById('clear-cascading-filters');
    
    // Mobile selectors
    this.makeSelectMobile = document.getElementById('make-select-mobile');
    this.modelSelectMobile = document.getElementById('model-select-mobile');
    this.placementSelectMobile = document.getElementById('placement-select-mobile');
    this.clearButtonMobile = document.getElementById('clear-cascading-filters-mobile');
    
    // Load filter data from the liquid-generated JSON
    this.filterData = this.loadFilterData();
    
    if (!this.form) {
      console.warn('Cascading filters form not found');
      return;
    }
    
    this.init();
  }
  
  /**
   * Load filter data from the JSON script tag generated by Liquid
   */
  loadFilterData() {
    const dataScript = document.getElementById('cascading-filters-data');
    if (!dataScript) {
      console.warn('Cascading filters data not found');
      return { makes: [], models: {}, placements: {} };
    }
    
    try {
      return JSON.parse(dataScript.textContent);
    } catch (error) {
      console.error('Error parsing cascading filters data:', error);
      return { makes: [], models: {}, placements: {} };
    }
  }
  
  /**
   * Initialize event listeners and set initial state
   */
  init() {
    // Set up event listeners for desktop
    if (this.makeSelect) {
      this.makeSelect.addEventListener('change', () => this.handleMakeChange());
    }
    if (this.modelSelect) {
      this.modelSelect.addEventListener('change', () => this.handleModelChange());
    }
    if (this.placementSelect) {
      this.placementSelect.addEventListener('change', () => this.handlePlacementChange());
    }
    if (this.clearButton) {
      this.clearButton.addEventListener('click', () => this.clearAllFilters());
    }
    
    // Set up event listeners for mobile
    if (this.makeSelectMobile) {
      this.makeSelectMobile.addEventListener('change', () => this.handleMakeChange(true));
    }
    if (this.modelSelectMobile) {
      this.modelSelectMobile.addEventListener('change', () => this.handleModelChange(true));
    }
    if (this.placementSelectMobile) {
      this.placementSelectMobile.addEventListener('change', () => this.handlePlacementChange(true));
    }
    if (this.clearButtonMobile) {
      this.clearButtonMobile.addEventListener('click', () => this.clearAllFilters());
    }
    
    // Initialize dropdown states based on current selections
    this.updateModelOptions();
    this.updatePlacementOptions();
    
    console.log('Cascading filters initialized');
  }
  
  /**
   * Handle Make dropdown change
   */
  handleMakeChange(isMobile = false) {
    const makeSelect = isMobile ? this.makeSelectMobile : this.makeSelect;
    const modelSelect = isMobile ? this.modelSelectMobile : this.modelSelect;
    const placementSelect = isMobile ? this.placementSelectMobile : this.placementSelect;
    
    if (!makeSelect || !modelSelect || !placementSelect) return;
    
    const selectedMake = makeSelect.value;
    
    // Sync the other version (desktop/mobile)
    const otherMakeSelect = isMobile ? this.makeSelect : this.makeSelectMobile;
    if (otherMakeSelect) {
      otherMakeSelect.value = selectedMake;
    }
    
    // Reset dependent dropdowns
    this.resetSelect(modelSelect, 'Select Model');
    this.resetSelect(placementSelect, 'Select Placement');
    
    // Reset the other version's dependent dropdowns too
    const otherModelSelect = isMobile ? this.modelSelect : this.modelSelectMobile;
    const otherPlacementSelect = isMobile ? this.placementSelect : this.placementSelectMobile;
    if (otherModelSelect) this.resetSelect(otherModelSelect, 'Select Model');
    if (otherPlacementSelect) this.resetSelect(otherPlacementSelect, 'Select Placement');
    
    if (selectedMake) {
      // Enable and populate model dropdown
      modelSelect.disabled = false;
      if (otherModelSelect) otherModelSelect.disabled = false;
      this.updateModelOptions();
    } else {
      // Disable dependent dropdowns
      modelSelect.disabled = true;
      placementSelect.disabled = true;
      if (otherModelSelect) otherModelSelect.disabled = true;
      if (otherPlacementSelect) otherPlacementSelect.disabled = true;
    }
    
    // Update products
    this.updateProducts();
  }
  
  /**
   * Handle Model dropdown change
   */
  handleModelChange(isMobile = false) {
    const modelSelect = isMobile ? this.modelSelectMobile : this.modelSelect;
    const placementSelect = isMobile ? this.placementSelectMobile : this.placementSelect;
    
    if (!modelSelect || !placementSelect) return;
    
    const selectedModel = modelSelect.value;
    
    // Sync the other version (desktop/mobile)
    const otherModelSelect = isMobile ? this.modelSelect : this.modelSelectMobile;
    if (otherModelSelect) {
      otherModelSelect.value = selectedModel;
    }
    
    // Reset placement dropdown
    this.resetSelect(placementSelect, 'Select Placement');
    
    // Reset the other version's placement dropdown too
    const otherPlacementSelect = isMobile ? this.placementSelect : this.placementSelectMobile;
    if (otherPlacementSelect) this.resetSelect(otherPlacementSelect, 'Select Placement');
    
    if (selectedModel) {
      // Enable and populate placement dropdown
      placementSelect.disabled = false;
      if (otherPlacementSelect) otherPlacementSelect.disabled = false;
      this.updatePlacementOptions();
    } else {
      // Disable placement dropdown
      placementSelect.disabled = true;
      if (otherPlacementSelect) otherPlacementSelect.disabled = true;
    }
    
    // Update products
    this.updateProducts();
  }
  
  /**
   * Handle Placement dropdown change
   */
  handlePlacementChange(isMobile = false) {
    const placementSelect = isMobile ? this.placementSelectMobile : this.placementSelect;
    
    if (!placementSelect) return;
    
    const selectedPlacement = placementSelect.value;
    
    // Sync the other version (desktop/mobile)
    const otherPlacementSelect = isMobile ? this.placementSelect : this.placementSelectMobile;
    if (otherPlacementSelect) {
      otherPlacementSelect.value = selectedPlacement;
    }
    
    this.updateProducts();
  }
  
  /**
   * Update model options based on selected make
   */
  updateModelOptions() {
    const selectedMake = (this.makeSelect && this.makeSelect.value) || (this.makeSelectMobile && this.makeSelectMobile.value) || '';
    
    if (!selectedMake || !this.filterData.models[selectedMake]) {
      return;
    }
    
    const models = this.filterData.models[selectedMake];
    
    // Update both desktop and mobile versions
    if (this.modelSelect) {
      this.populateSelect(this.modelSelect, models, 'Select Model');
    }
    if (this.modelSelectMobile) {
      this.populateSelect(this.modelSelectMobile, models, 'Select Model');
    }
  }
  
  /**
   * Update placement options based on selected make and model
   */
  updatePlacementOptions() {
    const selectedMake = (this.makeSelect && this.makeSelect.value) || (this.makeSelectMobile && this.makeSelectMobile.value) || '';
    const selectedModel = (this.modelSelect && this.modelSelect.value) || (this.modelSelectMobile && this.modelSelectMobile.value) || '';
    
    if (!selectedMake || !selectedModel) {
      return;
    }
    
    const placementKey = `${selectedMake}_${selectedModel}`;
    const placements = this.filterData.placements[placementKey] || [];
    
    // Update both desktop and mobile versions
    if (this.placementSelect) {
      this.populateSelect(this.placementSelect, placements, 'Select Placement');
    }
    if (this.placementSelectMobile) {
      this.populateSelect(this.placementSelectMobile, placements, 'Select Placement');
    }
  }
  
  /**
   * Populate a select element with options
   */
  populateSelect(selectElement, options, placeholder) {
    // Clear existing options except the first one
    selectElement.innerHTML = `<option value="">${placeholder}</option>`;
    
    // Add new options
    options.forEach(option => {
      if (option) {
        const optionElement = document.createElement('option');
        optionElement.value = option;
        optionElement.textContent = this.capitalizeWords(option);
        selectElement.appendChild(optionElement);
      }
    });
  }
  
  /**
   * Reset a select element to its default state
   */
  resetSelect(selectElement, placeholder) {
    selectElement.innerHTML = `<option value="">${placeholder}</option>`;
    selectElement.value = '';
  }
  
  /**
   * Clear all filter selections
   */
  clearAllFilters() {
    // Clear desktop selectors
    if (this.makeSelect) this.makeSelect.value = '';
    if (this.modelSelect) {
      this.resetSelect(this.modelSelect, 'Select Model');
      this.modelSelect.disabled = true;
    }
    if (this.placementSelect) {
      this.resetSelect(this.placementSelect, 'Select Placement');
      this.placementSelect.disabled = true;
    }
    
    // Clear mobile selectors
    if (this.makeSelectMobile) this.makeSelectMobile.value = '';
    if (this.modelSelectMobile) {
      this.resetSelect(this.modelSelectMobile, 'Select Model');
      this.modelSelectMobile.disabled = true;
    }
    if (this.placementSelectMobile) {
      this.resetSelect(this.placementSelectMobile, 'Select Placement');
      this.placementSelectMobile.disabled = true;
    }
    
    // Update products (clear filters)
    this.updateProducts();
  }
  
  /**
   * Update products based on current filter selections
   */
  updateProducts() {
    const make = (this.makeSelect && this.makeSelect.value) || (this.makeSelectMobile && this.makeSelectMobile.value) || '';
    const model = (this.modelSelect && this.modelSelect.value) || (this.modelSelectMobile && this.modelSelectMobile.value) || '';
    const placement = (this.placementSelect && this.placementSelect.value) || (this.placementSelectMobile && this.placementSelectMobile.value) || '';
    
    // Build filter tags
    const filterTags = [];
    
    if (make) {
      filterTags.push(`make_${make}`);
    }
    
    if (model && make) {
      filterTags.push(`model_${make}_${model}`);
    }
    
    if (placement && make && model) {
      filterTags.push(`placement_${make}_${model}_${placement}`);
    }
    
    // Update URL and trigger product grid update
    this.updateURL(filterTags);
  }
  
  /**
   * Update the URL with filter parameters and trigger product grid refresh
   */
  updateURL(filterTags) {
    const url = new URL(window.location);
    const params = new URLSearchParams(url.search);
    
    // Clear existing filter parameters
    for (const [key] of params) {
      if (key.includes('filter.p.tag')) {
        params.delete(key);
      }
    }
    
    // Add new filter parameters
    filterTags.forEach(tag => {
      params.append('filter.p.tag', tag);
    });
    
    // Update URL
    const newURL = `${url.pathname}?${params.toString()}`;
    
    // Use Shopify's section rendering to update the product grid
    this.fetchAndUpdateProductGrid(newURL);
  }
  
  /**
   * Fetch and update the product grid using Shopify's section rendering
   */
  async fetchAndUpdateProductGrid(url) {
    try {
      // Show loading state
      this.showLoadingState();
      
      // Fetch the updated section
      const sectionUrl = `${url}&section_id=main-collection-product-grid`;
      const response = await fetch(sectionUrl);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const html = await response.text();
      
      // Parse the response to extract just the ProductGridContainer content
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const newGridContainer = doc.querySelector('#ProductGridContainer');
      
      if (newGridContainer) {
        // Update the product grid container
        const currentGridContainer = document.getElementById('ProductGridContainer');
        if (currentGridContainer) {
          currentGridContainer.innerHTML = newGridContainer.innerHTML;
        }
      }
      
      // Update product count if available
      const newProductCount = doc.querySelector('#ProductCount, #ProductCountDesktop');
      if (newProductCount) {
        const countElements = document.querySelectorAll('#ProductCount, #ProductCountDesktop');
        countElements.forEach(element => {
          if (element) {
            element.innerHTML = newProductCount.innerHTML;
          }
        });
      }
      
      // Update the browser URL without refreshing the page
      window.history.pushState({}, '', url);
      
      // Hide loading state
      this.hideLoadingState();
      
      // Trigger custom event for other scripts that might need to know about the update
      document.dispatchEvent(new CustomEvent('cascadingFiltersUpdated', {
        detail: { url, filterTags: this.getCurrentFilterTags() }
      }));
      
    } catch (error) {
      console.error('Error updating product grid:', error);
      this.hideLoadingState();
      
      // Fallback: reload the page with new URL
      window.location.href = url;
    }
  }
  
  /**
   * Get current filter tags based on dropdown selections
   */
  getCurrentFilterTags() {
    const make = this.makeSelect.value;
    const model = this.modelSelect.value;
    const placement = this.placementSelect.value;
    
    const tags = [];
    
    if (make) tags.push(`make_${make}`);
    if (model && make) tags.push(`model_${make}_${model}`);
    if (placement && make && model) tags.push(`placement_${make}_${model}_${placement}`);
    
    return tags;
  }
  
  /**
   * Show loading state
   */
  showLoadingState() {
    const productGrid = document.getElementById('product-grid');
    if (productGrid) {
      productGrid.style.opacity = '0.5';
      productGrid.style.pointerEvents = 'none';
    }
    
    // Show loading overlay if it exists
    const loadingOverlay = document.querySelector('.loading-overlay');
    if (loadingOverlay) {
      loadingOverlay.style.display = 'flex';
    }
  }
  
  /**
   * Hide loading state
   */
  hideLoadingState() {
    const productGrid = document.getElementById('product-grid');
    if (productGrid) {
      productGrid.style.opacity = '1';
      productGrid.style.pointerEvents = 'auto';
    }
    
    // Hide loading overlay if it exists
    const loadingOverlay = document.querySelector('.loading-overlay');
    if (loadingOverlay) {
      loadingOverlay.style.display = 'none';
    }
  }
  
  /**
   * Capitalize words in a string
   */
  capitalizeWords(str) {
    return str.replace(/\b\w/g, char => char.toUpperCase());
  }
}

// Initialize cascading filters when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new CascadingFilters();
});

// Re-initialize if the page is updated via AJAX (for themes that use AJAX navigation)
document.addEventListener('shopify:section:load', () => {
  new CascadingFilters();
});